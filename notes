Compile command:

Compile:
gcc -Wall -std=c99 src/*.c -o renderer
Run:
./renderer

Compile and Run:
gcc -Wall -std=c99 src/*.c -o renderer && ./renderer

Generate compile commands:
bear -- make clean build


Application
â””â”€â”€ Engine
    â”œâ”€â”€ Window
    â”œâ”€â”€ Renderer
    â”‚   â”œâ”€â”€ ShaderManager
    â”‚   â”œâ”€â”€ TextureManager
    â”‚   â””â”€â”€ MeshManager
    â”œâ”€â”€ InputSystem
    â”œâ”€â”€ Camera
    â”œâ”€â”€ Scene
    â”‚   â”œâ”€â”€ Entity(s)
    â”‚   â”‚   â”œâ”€â”€ Transform
    â”‚   â”‚   â”œâ”€â”€ Mesh
    â”‚   â”‚   â””â”€â”€ Material
    â”‚   â””â”€â”€ Lights
    â”œâ”€â”€ UI (ImGui)
    â””â”€â”€ Time

Ownership vs Access (VERY important distinction)
Relationship	Meaning
Owns			Responsible for lifetime (unique_ptr)
Uses			Temporary access (reference or raw pointer)
Observes		Non-owning, optional (weak_ptr or raw pointer)

class Engine {
  std::unique_ptr<Window> window;
  std::unique_ptr<Renderer> renderer;
  std::unique_ptr<InputSystem> input;
  std::unique_ptr<Camera> camera;
  std::unique_ptr<Scene> scene;
};

This is an **excellent question** â€” and the fact youâ€™re asking it means youâ€™re already thinking like a systems programmer.

The short answer is:
ğŸ‘‰ **structure ownership + make invalid states unrepresentable**.

Letâ€™s turn this bug into a checklist you can reuse forever.

---

## 1ï¸âƒ£ Give each function **one job** (and one side-effect)

Your crash happened because:

* `loadTexture()` **both loaded data AND triggered GPU upload**
* `generateTextures()` **both uploaded AND freed memory**

That made call order fragile.

### Rule to follow

> A function should either **acquire**, **use**, or **release** a resource â€” not more than one.

### Better separation (mental model)

```text
load()        â†’ allocates CPU memory
upload()      â†’ consumes CPU memory
free()        â†’ releases CPU memory
```

Even if they live in one function, **think this way**.

---

## 2ï¸âƒ£ Encode ownership in the type system (RAII)

Raw pointers are easy to double-free.

Instead of:

```cpp
unsigned char* textureData;
```

Prefer:

```cpp
std::unique_ptr<unsigned char, void(*)(void*)> textureData;
```

Example:

```cpp
using StbiPtr = std::unique_ptr<unsigned char, void(*)(void*)>;

StbiPtr textureData{nullptr, stbi_image_free};
```

Now:

* Memory is freed **exactly once**
* Accidental double-free becomes impossible
* You canâ€™t forget to free it

This is *huge* for safety.

---

## 3ï¸âƒ£ Make â€œused alreadyâ€ state explicit

After you upload to the GPU, the CPU copy is no longer valid.

### Enforce that in code

```cpp
void Texture::generateTextures() {
  assert(textureData && "Texture data already freed or not loaded");

  ...
  stbi_image_free(textureData);
  textureData = nullptr;
}
```

Now mistakes crash **immediately**, not mysteriously later.

---

## 4ï¸âƒ£ Never call side-effect functions from constructors *and* helpers

Constructors should:

* Orchestrate
* Not hide work in helpers

### Bad (what caused this bug)

```cpp
loadTexture();   // secretly uploads + frees
generateTextures();
```

### Good

```cpp
loadTexture();
uploadToGPU();
```

If something allocates or frees memory:
ğŸ‘‰ **name it so**.

---

## 5ï¸âƒ£ Follow the â€œconsume-onceâ€ rule

If a function *consumes* a pointer, it should **invalidate it**.

### Pattern

```cpp
void uploadAndFree(unsigned char*& data) {
  ...
  stbi_image_free(data);
  data = nullptr;
}
```

This makes misuse impossible unless someone ignores the pointer state.

---

## 6ï¸âƒ£ Turn on tools that catch this instantly

### AddressSanitizer (always use during development)

```bash
-fsanitize=address -fno-omit-frame-pointer -g
```

This bug would have been caught **the moment it happened**, not later.

---

## 7ï¸âƒ£ Write â€œdefensive invariantsâ€ (cheap, powerful)

Add invariants at boundaries:

```cpp
void Texture::generateTextures() {
  if (!textureData) {
    throw std::logic_error("generateTextures called without textureData");
  }
}
```

You want bugs to:

* fail fast
* fail loud
* fail close to the cause

---

## 8ï¸âƒ£ Adopt a mental checklist (memorize this)

Before freeing memory, ask:

* â“ Who allocated this?
* â“ Who owns it now?
* â“ Is this function allowed to free it?
* â“ Can this function be called twice?

If any answer is unclear â†’ redesign.

---

## ğŸ† Gold-standard version (idiomatic C++)

```cpp
void Texture::loadTexture() {
  int w, h, ch;
  StbiPtr data(stbi_load(file, &w, &h, &ch, 0), stbi_image_free);
  if (!data) throw std::runtime_error("Failed to load texture");

  uploadToGPU(data.get(), w, h, ch);
}
```

Notice:

* No raw ownership stored
* No class-level pointer
* Impossible to double-free

---

## TL;DR (print this)

To avoid this forever:

1. One function = one responsibility
2. Use RAII (`unique_ptr`)
3. Null pointers after free
4. Assert invariants
5. Donâ€™t hide frees in helpers
6. Use ASan always
7. Make ownership obvious in names

If you want, next I can:

* refactor your texture class into a **bulletproof RAII version**
* show a **minimal OpenGL texture loader pattern**
* teach you how to design APIs that *prevent* misuse
* map these ideas to **C**, **Rust**, or **Go** patterns

